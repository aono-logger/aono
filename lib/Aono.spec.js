// Generated by CoffeeScript 2.3.0
(function() {
  var Aono, FakePromise, TEST_HIGH_WATERMARK, sinon;

  sinon = require("sinon");

  FakePromise = require("fake-promise").default;

  Aono = require("./Aono").default;

  TEST_HIGH_WATERMARK = 2;

  describe("Aono", function() {
    var logger, mocks, testedFactory;
    mocks = {
      timeProvider: sinon.stub(),
      handler0: {
        handle: sinon.stub()
      },
      pendingListener: sinon.spy(),
      writeListener: sinon.spy(),
      errorListener: sinon.spy(),
      pressureListener: sinon.spy(),
      syncListener: sinon.spy()
    };
    testedFactory = null;
    logger = null;
    beforeEach(function() {
      testedFactory = new Aono(mocks.timeProvider, TEST_HIGH_WATERMARK);
      testedFactory.on("pending", mocks.pendingListener);
      testedFactory.on("write", mocks.writeListener);
      testedFactory.on("error", mocks.errorListener);
      testedFactory.on("pressure", mocks.pressureListener);
      testedFactory.on("sync", mocks.syncListener);
      return logger = testedFactory.getLogger("test");
    });
    afterEach(function() {
      mocks.timeProvider.resetHistory();
      mocks.timeProvider.resetBehavior();
      mocks.handler0.handle.resetHistory();
      mocks.handler0.handle.resetBehavior();
      mocks.pendingListener.resetHistory();
      mocks.writeListener.resetHistory();
      mocks.errorListener.resetHistory();
      mocks.pressureListener.resetHistory();
      return mocks.syncListener.resetHistory();
    });
    describe("given no handlers", function() {
      return it("logs without any problem", function() {
        return logger.log("mayday", "we are blind");
      });
    });
    return describe("given single handler", function() {
      beforeEach(function() {
        return testedFactory.addHandler(mocks.handler0);
      });
      describe("before any log entries", function() {
        it("is synced", function() {
          return testedFactory.isSynced().should.equal(true);
        });
        return it("calling .retry throws", function() {
          return (function() {
            return testedFactory.retry();
          }).should.throw(".retry() must be called only after emitting 'error'");
        });
      });
      describe("when after first log entry", function() {
        var promise0;
        promise0 = null;
        beforeEach(function() {
          mocks.timeProvider.returns(12345);
          promise0 = new FakePromise;
          mocks.handler0.handle.returns(promise0);
          return logger.log("info", "first entry");
        });
        it("is not synced", function() {
          return testedFactory.isSynced().should.equal(false);
        });
        it("emits 'pending'", function() {
          return mocks.pendingListener.should.have.callCount(1);
        });
        it("does not emit 'sync'", function() {
          return mocks.syncListener.should.have.callCount(0);
        });
        it("is not synced", function() {
          return testedFactory.isSynced().should.equal(false);
        });
        it("immediately passes proper log entry to the handler", function() {
          return mocks.handler0.handle.should.have.callCount(1).and.have.been.calledWith([
            {
              timestamp: 12345,
              logger: "test",
              level: "info",
              message: "first entry",
              meta: {}
            }
          ]);
        });
        describe("and after second and third log entry", function() {
          beforeEach(function() {
            mocks.timeProvider.resetHistory().resetBehavior();
            mocks.timeProvider.onCall(0).returns(98765);
            mocks.timeProvider.onCall(1).returns(111111);
            mocks.handler0.handle.resetHistory();
            mocks.pendingListener.resetHistory();
            logger.log("debug", "second entry");
            return logger.log("warn", "entry", {
              number: "three"
            });
          });
          it("is not synced", function() {
            return testedFactory.isSynced().should.equal(false);
          });
          it("does not emit second 'pending'", function() {
            return mocks.pendingListener.should.have.callCount(0);
          });
          it("does not emit 'sync'", function() {
            return mocks.syncListener.should.have.callCount(0);
          });
          it("does not pass second and third log entry to the handler", function() {
            return mocks.handler0.handle.should.have.callCount(0);
          });
          it("emits \'pressure\' with proper writeId", function() {
            return mocks.pressureListener.should.have.callCount(1).and.have.been.calledWith(0);
          });
          return describe("and after first write successfully ends", function() {
            var promise1;
            promise1 = null;
            beforeEach(function() {
              mocks.handler0.handle.resetBehavior();
              promise1 = new FakePromise;
              mocks.handler0.handle.returns(promise1);
              promise0.setResult(void 0).resolve();
              return void 0; // not returning the promise
            });
            it("is not synced", function() {
              return testedFactory.isSynced().should.equal(false);
            });
            it("does not emit second 'pending'", function() {
              return mocks.pendingListener.should.have.callCount(0);
            });
            it("does not emit 'sync'", function() {
              return mocks.syncListener.should.have.callCount(0);
            });
            it("emits 'write' with first log entry", function() {
              return mocks.writeListener.should.have.callCount(1).and.have.been.calledWith([
                {
                  timestamp: 12345,
                  logger: "test",
                  level: "info",
                  message: "first entry",
                  meta: {}
                }
              ]);
            });
            it("passes second and third log to the handler", function() {
              return mocks.handler0.handle.should.have.callCount(1).and.have.been.calledWith([
                {
                  timestamp: 98765,
                  logger: "test",
                  level: "debug",
                  message: "second entry",
                  meta: {}
                },
                {
                  timestamp: 111111,
                  logger: "test",
                  level: "warn",
                  message: "entry",
                  meta: {
                    number: "three"
                  }
                }
              ]);
            });
            describe("and after second write successfully ends", function() {
              beforeEach(function() {
                mocks.handler0.handle.resetHistory();
                mocks.writeListener.resetHistory();
                promise1.setResult(void 0).resolve();
                return void 0; // not returning the promise
              });
              it("does not emit second 'pending'", function() {
                return mocks.pendingListener.should.have.callCount(0);
              });
              it("emits 'sync'", function() {
                return mocks.syncListener.should.have.callCount(1);
              });
              it("is synced", function() {
                return testedFactory.isSynced().should.equal(true);
              });
              it("emits 'write' with second and third log entry", function() {
                return mocks.writeListener.should.have.callCount(1).and.have.been.calledWith([
                  {
                    timestamp: 98765,
                    logger: "test",
                    level: "debug",
                    message: "second entry",
                    meta: {}
                  },
                  {
                    timestamp: 111111,
                    logger: "test",
                    level: "warn",
                    message: "entry",
                    meta: {
                      number: "three"
                    }
                  }
                ]);
              });
              return it("does not pass anything to the handler", function() {
                return mocks.handler0.handle.should.have.callCount(0);
              });
            });
            return describe("and after fourth and fifth log entry", function() {
              beforeEach(function() {
                mocks.timeProvider.resetHistory().resetBehavior();
                mocks.timeProvider.onCall(0).returns(444444);
                mocks.timeProvider.onCall(1).returns(555555);
                mocks.handler0.handle.resetHistory();
                mocks.pressureListener.resetHistory();
                mocks.syncListener.resetHistory();
                logger.log("doomsday", "message");
                return logger.log("salvation", "all will be fine");
              });
              it("is not synced", function() {
                return testedFactory.isSynced().should.equal(false);
              });
              it("does not emit 'sync'", function() {
                return mocks.syncListener.should.have.callCount(0);
              });
              it("emits 'pending'", function() {
                return mocks.pendingListener.should.have.callCount(0);
              });
              it("does not pass fouth and fifth log entry to the handler", function() {
                return mocks.handler0.handle.should.have.callCount(0);
              });
              return it("emits \'pressure\' with proper writeId", function() {
                return mocks.pressureListener.should.have.callCount(1).and.have.been.calledWith(1);
              });
            });
          });
        });
        describe("and after first write successfully ends", function() {
          var promise1;
          promise1 = null;
          beforeEach(function() {
            mocks.handler0.handle.resetBehavior();
            mocks.pendingListener.resetHistory();
            promise1 = new FakePromise;
            mocks.handler0.handle.returns(promise1);
            promise0.setResult(void 0).resolve();
            return void 0; // not returning the promise
          });
          it("is synced", function() {
            return testedFactory.isSynced().should.equal(true);
          });
          it("emits 'sync'", function() {
            return mocks.syncListener.should.have.callCount(1);
          });
          it("doesnt emit 'pending'", function() {
            return mocks.pendingListener.should.have.callCount(0);
          });
          it("calling .retry throws", function() {
            return (function() {
              return testedFactory.retry();
            }).should.throw(".retry() must be called only after emitting 'error'");
          });
          return describe("and after second log entry", function() {
            beforeEach(function() {
              mocks.timeProvider.resetHistory().resetBehavior();
              mocks.timeProvider.returns(98765);
              mocks.handler0.handle.resetHistory();
              mocks.syncListener.resetHistory();
              return logger.log("debug", "entry", {
                number: "two"
              });
            });
            it("is not synced", function() {
              return testedFactory.isSynced().should.equal(false);
            });
            it("doesnt emit 'sync'", function() {
              return mocks.syncListener.should.have.callCount(0);
            });
            it("emits 'pending'", function() {
              return mocks.pendingListener.should.have.callCount(1);
            });
            return it("immediately passes second log entry to the handler", function() {
              return mocks.handler0.handle.should.have.callCount(1).and.have.been.calledWith([
                {
                  timestamp: 98765,
                  logger: "test",
                  level: "debug",
                  message: "entry",
                  meta: {
                    number: "two"
                  }
                }
              ]);
            });
          });
        });
        return describe("and after first write fails", function() {
          var error;
          error = new Error("something went wrong");
          beforeEach(function() {
            promise0.reject(error).reject();
            return void 0; // not returning the promise
          });
          it("emits the error", function() {
            return mocks.errorListener.should.have.callCount(1).and.have.been.calledWith(error, [
              {
                timestamp: 12345,
                logger: "test",
                level: "info",
                message: "first entry",
                meta: {}
              }
            ]);
          });
          it("is not synced", function() {
            return testedFactory.isSynced().should.equal(false);
          });
          return describe("and after second log entry", function() {
            beforeEach(function() {
              mocks.timeProvider.resetHistory().resetBehavior();
              mocks.timeProvider.returns(98765);
              mocks.handler0.handle.resetHistory();
              return logger.log("debug", "entry", {
                number: "two"
              });
            });
            it("does not pass second log entry to the handler", function() {
              return mocks.handler0.handle.should.have.callCount(0);
            });
            return describe("and after calling .retry", function() {
              var promise1;
              promise1 = null;
              beforeEach(function() {
                mocks.handler0.handle.resetHistory();
                mocks.handler0.handle.resetBehavior();
                promise1 = new FakePromise;
                mocks.handler0.handle.returns(promise1);
                return testedFactory.retry();
              });
              return it("immediately passes the first log entry to the handler", function() {
                return mocks.handler0.handle.should.have.callCount(1).and.have.been.calledWith([
                  {
                    timestamp: 12345,
                    logger: "test",
                    level: "info",
                    message: "first entry",
                    meta: {}
                  }
                ]);
              });
            });
          });
        });
      });
      return describe("when after log entry containing error as meta", function() {
        var fakeError, promise0;
        promise0 = null;
        fakeError = {
          name: "TestError",
          message: "error",
          stack: "a\nb\nc"
        };
        beforeEach(function() {
          mocks.timeProvider.returns(12345);
          promise0 = new FakePromise;
          mocks.handler0.handle.returns(promise0);
          return logger.log("error", "error", fakeError);
        });
        return it("passes entry with preprocessed error to handler", function() {
          return mocks.handler0.handle.should.have.callCount(1).and.have.been.calledWith([
            {
              timestamp: 12345,
              logger: "test",
              level: "error",
              message: "error",
              meta: {
                stacktrace: ["a",
            "b",
            "c"]
              }
            }
          ]);
        });
      });
    });
  });

}).call(this);
